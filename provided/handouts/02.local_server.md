+++
title = "DKVS: Distributed Key-Value Store --- "
template = "project/page.html"
weight = 3

[extra]
week = 6
revision = "2024.10.15 / 1"
+++

## Table of contents

- [Table of contents](#table-of-contents)
- [Get updates](#get-updates)
- [Introduction](#introduction)
- [I. General description of the command line tools](#i-general-description-of-the-command-line-tools)
- [II. Low-level modules](#ii-low-level-modules)
  - [II.1. Arguments (`args.[ch]`)](#ii1-arguments-argsch)
  - [II.2. Node  (`node.[ch]`)](#ii2-node--nodech)
  - [II.3. Node list  (`node_list.[ch]`)](#ii3-node-list--node_listch)
  - [II.4. Ring  (`ring.[ch]`)](#ii4-ring--ringch)
  - [II.5. Client  (`client.[ch]`)](#ii5-client--clientch)
  - [II.6. Fake network](#ii6-fake-network)
- [III. Implementing command-line tools](#iii-implementing-command-line-tools)
  - [III.1. `dkvs-client` commands](#iii1-dkvs-client-commands)
  - [III.2. `main()`](#iii2-main)
  - [III.3. `fake-dkvs-client` executable](#iii3-fake-dkvs-client-executable)
- [IV. Testing and debugging](#iv-testing-and-debugging)
  - [Unit tests](#unit-tests)
  - [End-to-end tests](#end-to-end-tests)
  - [Feedback](#feedback)
- [V. Advice](#v-advice)


## Get updates

To get the new material on your project repository, you have to:

- check that you don't already have the upstream reference repository:

        git remote -v
    
    if you see only two lines or if you don't see `projprogsys-epfl/cs202-25-project.git` in any line, you don't have it and must add it (next step);

- **only once**: add the upstream reference repository (I though this was automatically donc by Github Classroom, but it seems not):

        git remote add upstream git@github.com:projprogsys-epfl/cs202-25-project.git

    check it was properly added by doing again

        git remote -v

From now on, every time you want to fetch updates from us, first be up-to-date with your own code (i.e. you pushed all your commits) and then do (only one of you has to do that, the other will simply `git pull` as usual):

    git fetch upstream
    git merge upstream/main
    git push

## Introduction

The aim of this week is to setup the client-side command-line tool ("program", in other words) to interact with the DKVS infrastructure (review the [general presentation document](../01-main/) if necessary).
Even though this week infrastructure is quite simple (a single server, *N*=*W*=*R*=1), it's important for your efficiency to organize yourself well, module by module with the broad view in perspective and to *systematically* test your implementations.

So this week's goal is to achieve a *local* infrastructure only, on a single server, without redundancy, using the [hash tables implemented last week](../01-hashtable/).
Since networking will not be implemented before weekÂ 10 (so that you have seen the proper concepts in class), we will, for now, fake the network interactions. Instead of actually sending network requests to the nodes, the operations will use a local hashtable to _simulate_ network interactions.

We here start by describing the higher-level tools before going on to describe the lower-level implementation modules. As this week's work is quite substantial, it's important to divide it up between the two of you; for example, one of you can deal with the argument parsing (`args.[ch]`, `parse_args()` and `client.c`), while the other deals with "network" (fake) modeling and interactions (`node`, `node-list`, `ring` and `dkvs-client get` and `dkvs-client put`). But this is only _one_ possible example of organization among others.

## I. General description of the command line tools

The command-line tool we start implementing this week is named `dkvs-client`. The general syntax of `dkvs-client` is:

```sh
dkvs-client <command> [-r R] [-w W] [-n N] -- ...
```

There is only one mandatory argument, `<command>`. We will for now focus only on two commands: `put` and `get`, detailed below. The three optional flags `-r`, `-w` and `-n` take a strictly positive integer as parameter (more explainations later). Then a list of specific arguments can be provided, to be placed after `--`. Some simple examples are provided below.

The `put` command inserts a key-value pair in the store. For example, to add the following two key-value associations
```text
a -> "hi a"
b -> "hello b"
```
we will do:
```sh
> ./dkvs-client put -- "a" "hi a"
OK
> ./dkvs-client put -- "b" "hello b"
OK
```

If some key already existed in the table, the `put` command simply overwrites new value. For example, if the above table was containing
```text
a -> "hello a"
c -> "hi c"
```
before the above two `put` commands, then it contains:
`
a -> "hi a"
b -> "hello b"
c -> "hi c"
`
after the above two `put` commands.

The `get` command fetches key value in the store. For instance, with the former table:
```sh
> ./dkvs-client get -- "a"
OK hi a
> ./dkvs-client get -- "b"
OK hello b
> ./dkvs-client get -- "d"
FAIL
> ./dkvs-client get -- "some key"
FAIL
```


## II. Low-level modules

We have modularized the infrastructure for this project as follows (review the [general presentation document](../01-main/) if necessary):

- `args.[ch]`: managing command line arguments;
- `client.[ch]`: providing initialization and termination functions for a client;
- networking:
  - `network.h`: interface for client-server communication;
  - `fake-network.c` (provided): a fake implementation of client-server communication functions for `put` (write key-value) and `get` (read value) requests; you can adapt it for your own tests, see the [dedicated section](#ii6-fake-network);
- DKVS:
   - `ring.[ch]`: the key ring abstraction; in this project, it'll be implemented as a **dynamic array** of nodes;
   - `node_list.[ch]`: a dynamic array of nodes;
   - `node.[ch]`: a key ring node, i.e. one storage place for key-values pairs.

### II.1. Arguments (`args.[ch]`)

This module handles the parsing and storage of command line arguments. It exposes a `struct args`, and its typedef `args_t`, as well as the function `parse_args()`. See `args.h`.

If you didn't yet, we recommand you have a look at the two complement lectures (in French):

- [argc and argv](https://mediaspace.epfl.ch/media/argc%20%26%20argv/0_tcgu82nh?);
- [argc and argv: example](https://mediaspace.epfl.ch/media/argc%20%26%20argv%3A%20example/0_yhuduq8v).

In a file `args.c` (to be created), you have to implement the function `parse_opt_args()` (see prototype in `args.h`), which initializes the `args_t` according to optional arguments, removes them and the `"--"` from the argument list and leaves all the other following arguments (in the argument list). Of course, `argc` shall be updated consistently.

`supported_args` is an information value to indicate what type of argument we want to have. It's making use of `arg_kind` bit flags. For instance, if we want to have N and W for a specific command, we would call

    parse_opt_args(&args, TOTAL_SERVERS | PUT_NEEDED, &argc, &argv);

**Note:** even though the `-r`, `-w` and `-n` flags are optional, they must be initialized using default values if not present (corresponding default values are provided in `args.h`).

An error code shall be returned to indicate whether an error occurred, either:

- `ERR_NONE`: no errors;
- `ERR_INVALID_ARGUMENT`: if one of the pointer given to `parse_args()` is `NULL`; this check should be present in all your function and we will not repeat it afterwards;
- `ERR_INVALID_COMMAND`: if the command line arguments do not match the above syntax.

### II.2. Node  (`node.[ch]`)

The `node` layer is quite simple and only serve to better structure the code in layers. It represent the ring node abstraction which, for the moment and up to week 11, will simply be one server.

For this week, simply define the `struct node` to contain one adress (an immutable string).

In `node_init()` simply assign the address. `port` and `node_id` are unused for the moment.

`node_end()` contains what should be done when a node comes to an end. Certainly nothing for the moment.

There is no need to do the two other functions (`node_cmp_...`) for the moment.

### II.3. Node list  (`node_list.[ch]`)

A node list will be usefull to represent the ring.

Define the type `struct node_list` as a **dynamic**  array of nodes.

Then define `node_list_add()` and `node_list_free()` (usual functions for dynamic arrays).

The only unusual function w.r.t. dynamic arrays is the initialization: here the initialization function is named `get_nodes()` and will be a bit more complex once we have the real network (getting all the nodes from the ring). For the moment, simply create a `node`, with `DKVS_DEFAULT_IP` (its address), `DKVS_DEFAULT_PORT` (unused) and 0 id (unused); and add it to the list.

No need to define `node_list_sort()` for the moment.

### II.4. Ring  (`ring.[ch]`)

In this project, a ring is simplified to be simply reduced to the list of nodes (i.e. a dynamic array of nodes, `node_list`).

Simply define `ring_init()` and `ring_free()` appropriately.

### II.5. Client  (`client.[ch]`)

The "client" module is not very developed. It contains only two functions: initialization and end-of-use of a client.

You must first define the `client_t` type in `client.h`, which for the moment only contains the arguments parsed from the command line (`args_t`) and a ring.

Regarding `client.c`:

- for initialization, it needs to parse the command line arguments received as parameter and initialize its ring;
- for the end of a client, you only need to free the resources used by the client (for the moment: its ring).

Those functions also return error codes indicating whether they succeeded. If they call a function which returns an error, this error should be returned.  
**Note**: This behavior should be present in all your code and will not be repeated.

### II.6. Fake network

The network layer is the highest tool layer, modeling client-server communication. It offers two functions for managing these communications: `network_put()` for request exchange during key-value writing, and `network_get()` for value reading. See `network.h` for the interface (which will remain the same for real network interactions).

For now, we provide you with a fake implementation of this layer in `fake_network.c`, `fake1.h` and `fake2.h`. It uses a local hashtable, therefore changes are not persisted across multiple calls.

Each `fake%.h` file contains a macro definition for `MAKE_FAKE_NETWORK`, which is used to initialize the key-value store before running the command. When compiling the project, for all `fake%.h`; it will generate a corresponding `fake-dkvs-client-%`, which runs the command on its key-value store.

## III. Implementing command-line tools

### III.1. `dkvs-client` commands

`cli_client_get()` needs to be implemented in `dkvs-client-get.c`, and `cli_client_put()` in `dkvs-client-put.c`. Their prototype and documentation are available in `dkvs-client-cmds.h`. They receive as parameter a `client_t`, and their arguments via `argc` and `argv`:
remember (from `argcs.c` and `parse_opt_args()` descriptions above) that the argument(s) they need (provided on the command line after `--`) remain in `argv`.

Use the appropriate functions from `network.h` to communicate with the DKVS ring.

In case of invalid arguments, these functions shall return, as usual, the `ERR_INVALID_ARGUMENT` error code.
Neither a key nor a value shall not be longer than `MAX_MSG_ELEM_SIZE` characters.

`cli_client_get()` will print "`OK <value>`" if it got a value from the network and "`FAIL`" if not (see examples above). It will return the error code it code from the network call.

`cli_client_put()` behave the same way, except it simply prints "`OK`" (no value) in case of successful put.

### III.2. `main()`

The role of the `main()` function, to be put in `dkvs-client.c`, is simply to receive the command line arguments and call the corresponding function from `dkvs-client-cmds.h` (`cli_client_get()` if the argument is `"get"` and `cli_client_put()` if it's `"put"`). Of course, everything needed shall be properly initialized (use `TOTAL_SERVERS | GET_NEEDED` flags for `get` and `TOTAL_SERVERS | PUT_NEEDED` flags for `put`; and remember that `get` requires one argument (the key) whereas `put` requires two).

Have a look a the provided code and complete the `commands` array with the appropriate values so as to have the `get` and `put` command properly handled.

### III.3. `fake-dkvs-client` executable

To make use of the provided `fake_network` (or any other of your own), `dkvs-client` has to be linked with it.
If you didn't update your `Makefile` already, please do by importing it from `provided`. As said [above](#ii6-fake-network), you will have a separate `fake-dkvs-client-%` for each `fake%.h`. Since we provide you with `fake1.h` and `fake2.h`, you should have two fake executables. If you take a look at `fake1.h`, you'll see that it contains an empty key-value store; while `fake2.h` has a few entries.

You can test this with:

```sh
$ ./fake-dkvs-client-1 get -- a
...
==== end of fake network init =================
FAIL
ERROR: Not found
...

$ ./fake-dkvs-client-2 get -- a
...
==== end of fake network init =================
OK hello a
```

Feel free to add as many `fake%.h` as you want for your own tests; the `Makefile` will automatically detect them and build the corresponding executables.

## IV. Testing and debugging

### Unit tests

Similarly to last week, we provide you with a few unit tests in `provided/tests/unit`. We strongly recommend you to add your own tests **after copying them into your `done/` directory**.

### End-to-end tests

Since you now have fully working executables, we'll start using end-to-end tests; i.e. tests that check the functionality from a user perspective. You can find them in `provided/tests/end-to-end`.

Their workflow is rather simple: they start the executable with some parameters and check that its output is correct. The tests are written in Python using the native `unittests` library; we also provide a class `DKVSTests` with a few utilies to run a (potentially fake) executable and check its prints and return code.

### Feedback

We also provide a `make feedback` (`make feedback-VM-CO` if you're working on EPFL VMs) which gives _partial_ feedback on your work. This is normally used for a _minimal_ **final** check of your work. It's **much better** to run **local** tests directly on your machine beforehand (including more tests you've added yourself, if necessary) as described above.

The Docker image used by `make feedback` will be tagged `latest` every week. If you want to run feedback for a specific week, change (in the `Makefile` at the line that defines `IMAGE`) this `latest` tag to `weekNN` where `NN` is the desired week number, e.g.:

```
IMAGE=chappeli/cs202-feedback:week06
```


## V. Advice

**WARNING:** there are _many_ possible sources of error in all these functions. You must systematically check all arguments, as well as the return values of tool functions used in a higher-level function. It's worth imagining that each function can be tested separately with "_bizarre_" inputs (which we'll do). If you have any questions, don't hesitate to ask during the exercise sessions.

We strongly advise you to work regularly and systematically to make weekly tags (if your corresponding work is operational) in order to benefit from our test reports.
